/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { forkJoin } from 'rxjs';
import { HttpClient } from '@angular/common/http';
import { Location } from '@angular/common';
import { TcAccessControlService } from '../services/tc-access-control.service';
import { AccessControlConfigurationResolver } from './accessControlConfiguration.resolver';
import { map } from 'rxjs/operators';
import { TcRolesService } from '../services/tc-roles-service.ts.service';
import { TcSharedStateService, TcGeneralConfigService } from '@tibco-tcstk/tc-core-lib';
import { LiveAppsService } from '../services/live-apps.service';
import { RoleActiveResolver } from './role-active.resolver';
export class AccessResolver {
    /**
     * @param {?} location
     * @param {?} http
     * @param {?} accessControlService
     * @param {?} rolesService
     * @param {?} liveapps
     * @param {?} route
     * @param {?} sharedStateService
     * @param {?} generalConfigService
     * @param {?} router
     */
    constructor(location, http, accessControlService, rolesService, liveapps, route, sharedStateService, generalConfigService, router) {
        this.location = location;
        this.http = http;
        this.accessControlService = accessControlService;
        this.rolesService = rolesService;
        this.liveapps = liveapps;
        this.route = route;
        this.sharedStateService = sharedStateService;
        this.generalConfigService = generalConfigService;
        this.router = router;
    }
    /**
     * @return {?}
     */
    resolve() {
        /** @type {?} */
        const accessControlConfiguration$ = new AccessControlConfigurationResolver(this.location, this.http, this.accessControlService).resolve();
        // we will need the active user role
        /** @type {?} */
        const activeRoleRes = new RoleActiveResolver(this.rolesService, this.liveapps, this.sharedStateService, this.generalConfigService, this.http, this.location, this.router);
        /** @type {?} */
        const activeRole$ = activeRoleRes.resolve();
        // run both in parallel then check access
        /** @type {?} */
        const accessControl$ = forkJoin(accessControlConfiguration$, activeRole$).pipe(map((/**
         * @param {?} __0
         * @return {?}
         */
        ([accessConfig, activeRole]) => {
            return accessConfig.configuration.find((/**
             * @param {?} element
             * @return {?}
             */
            element => element.roleId === activeRole.id));
        })));
        return accessControl$;
    }
}
AccessResolver.decorators = [
    { type: Injectable }
];
/** @nocollapse */
AccessResolver.ctorParameters = () => [
    { type: Location },
    { type: HttpClient },
    { type: TcAccessControlService },
    { type: TcRolesService },
    { type: LiveAppsService },
    { type: ActivatedRoute },
    { type: TcSharedStateService },
    { type: TcGeneralConfigService },
    { type: Router }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    AccessResolver.prototype.location;
    /**
     * @type {?}
     * @private
     */
    AccessResolver.prototype.http;
    /**
     * @type {?}
     * @private
     */
    AccessResolver.prototype.accessControlService;
    /**
     * @type {?}
     * @private
     */
    AccessResolver.prototype.rolesService;
    /**
     * @type {?}
     * @private
     */
    AccessResolver.prototype.liveapps;
    /**
     * @type {?}
     * @private
     */
    AccessResolver.prototype.route;
    /**
     * @type {?}
     * @private
     */
    AccessResolver.prototype.sharedStateService;
    /**
     * @type {?}
     * @private
     */
    AccessResolver.prototype.generalConfigService;
    /**
     * @type {?}
     * @private
     */
    AccessResolver.prototype.router;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWNjZXNzLnJlc29sdmVyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHRpYmNvLXRjc3RrL3RjLWxpdmVhcHBzLWxpYi8iLCJzb3VyY2VzIjpbImxpYi9yZXNvbHZlcnMvYWNjZXNzLnJlc29sdmVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBVSxjQUFjLEVBQUUsTUFBTSxFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFDaEUsT0FBTyxFQUFjLFFBQVEsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUU1QyxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDbEQsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLHVDQUF1QyxDQUFDO0FBQy9FLE9BQU8sRUFBRSxrQ0FBa0MsRUFBRSxNQUFNLHVDQUF1QyxDQUFDO0FBQzNGLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNyQyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0seUNBQXlDLENBQUM7QUFDekUsT0FBTyxFQUFFLG9CQUFvQixFQUFFLHNCQUFzQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDeEYsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLCtCQUErQixDQUFDO0FBQ2hFLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBRzVELE1BQU0sT0FBTyxjQUFjOzs7Ozs7Ozs7Ozs7SUFFdkIsWUFDWSxRQUFrQixFQUNsQixJQUFnQixFQUNoQixvQkFBNEMsRUFDNUMsWUFBNEIsRUFDNUIsUUFBeUIsRUFDekIsS0FBcUIsRUFDckIsa0JBQXdDLEVBQ3hDLG9CQUE0QyxFQUM1QyxNQUFjO1FBUmQsYUFBUSxHQUFSLFFBQVEsQ0FBVTtRQUNsQixTQUFJLEdBQUosSUFBSSxDQUFZO1FBQ2hCLHlCQUFvQixHQUFwQixvQkFBb0IsQ0FBd0I7UUFDNUMsaUJBQVksR0FBWixZQUFZLENBQWdCO1FBQzVCLGFBQVEsR0FBUixRQUFRLENBQWlCO1FBQ3pCLFVBQUssR0FBTCxLQUFLLENBQWdCO1FBQ3JCLHVCQUFrQixHQUFsQixrQkFBa0IsQ0FBc0I7UUFDeEMseUJBQW9CLEdBQXBCLG9CQUFvQixDQUF3QjtRQUM1QyxXQUFNLEdBQU4sTUFBTSxDQUFRO0lBQ3RCLENBQUM7Ozs7SUFFTCxPQUFPOztjQUVHLDJCQUEyQixHQUFHLElBQUksa0NBQWtDLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLE9BQU8sRUFBRTs7O2NBR25JLGFBQWEsR0FBRyxJQUFJLGtCQUFrQixDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsa0JBQWtCLEVBQUUsSUFBSSxDQUFDLG9CQUFvQixFQUFFLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDOztjQUNuSyxXQUFXLEdBQUcsYUFBYSxDQUFDLE9BQU8sRUFBRTs7O2NBR3JDLGNBQWMsR0FBRyxRQUFRLENBQUMsMkJBQTJCLEVBQUUsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUMxRSxHQUFHOzs7O1FBQUMsQ0FBQyxDQUFDLFlBQVksRUFBRSxVQUFVLENBQUMsRUFBRSxFQUFFO1lBQy9CLE9BQU8sWUFBWSxDQUFDLGFBQWEsQ0FBQyxJQUFJOzs7O1lBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsTUFBTSxLQUFLLFVBQVUsQ0FBQyxFQUFFLEVBQUMsQ0FBQztRQUN4RixDQUFDLEVBQUMsQ0FDTDtRQUVELE9BQU8sY0FBYyxDQUFDO0lBQzFCLENBQUM7OztZQS9CSixVQUFVOzs7O1lBVEYsUUFBUTtZQURSLFVBQVU7WUFFVixzQkFBc0I7WUFHdEIsY0FBYztZQUVkLGVBQWU7WUFWUCxjQUFjO1lBU3RCLG9CQUFvQjtZQUFFLHNCQUFzQjtZQVRwQixNQUFNOzs7Ozs7O0lBaUIvQixrQ0FBMEI7Ozs7O0lBQzFCLDhCQUF3Qjs7Ozs7SUFDeEIsOENBQW9EOzs7OztJQUNwRCxzQ0FBb0M7Ozs7O0lBQ3BDLGtDQUFpQzs7Ozs7SUFDakMsK0JBQTZCOzs7OztJQUM3Qiw0Q0FBZ0Q7Ozs7O0lBQ2hELDhDQUFvRDs7Ozs7SUFDcEQsZ0NBQXNCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtSZXNvbHZlLCBBY3RpdmF0ZWRSb3V0ZSwgUm91dGVyfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgZm9ya0pvaW4gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFJvdXRlQWNjZXNzQ29udHJvbENvbmZpZ3VyYXRpb25FbGVtZW50IH0gZnJvbSAnLi4vbW9kZWxzL3RjLWdyb3Vwcy1kYXRhJztcbmltcG9ydCB7IEh0dHBDbGllbnQgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgeyBMb2NhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBUY0FjY2Vzc0NvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvdGMtYWNjZXNzLWNvbnRyb2wuc2VydmljZSc7XG5pbXBvcnQgeyBBY2Nlc3NDb250cm9sQ29uZmlndXJhdGlvblJlc29sdmVyIH0gZnJvbSAnLi9hY2Nlc3NDb250cm9sQ29uZmlndXJhdGlvbi5yZXNvbHZlcic7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUY1JvbGVzU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL3RjLXJvbGVzLXNlcnZpY2UudHMuc2VydmljZSc7XG5pbXBvcnQgeyBUY1NoYXJlZFN0YXRlU2VydmljZSwgVGNHZW5lcmFsQ29uZmlnU2VydmljZSB9IGZyb20gJ0B0aWJjby10Y3N0ay90Yy1jb3JlLWxpYic7XG5pbXBvcnQgeyBMaXZlQXBwc1NlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9saXZlLWFwcHMuc2VydmljZSc7XG5pbXBvcnQgeyBSb2xlQWN0aXZlUmVzb2x2ZXIgfSBmcm9tICcuL3JvbGUtYWN0aXZlLnJlc29sdmVyJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEFjY2Vzc1Jlc29sdmVyIGltcGxlbWVudHMgUmVzb2x2ZTxPYnNlcnZhYmxlPFJvdXRlQWNjZXNzQ29udHJvbENvbmZpZ3VyYXRpb25FbGVtZW50Pj4ge1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgbG9jYXRpb246IExvY2F0aW9uLFxuICAgICAgICBwcml2YXRlIGh0dHA6IEh0dHBDbGllbnQsXG4gICAgICAgIHByaXZhdGUgYWNjZXNzQ29udHJvbFNlcnZpY2U6IFRjQWNjZXNzQ29udHJvbFNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgcm9sZXNTZXJ2aWNlOiBUY1JvbGVzU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBsaXZlYXBwczogTGl2ZUFwcHNTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIHJvdXRlOiBBY3RpdmF0ZWRSb3V0ZSxcbiAgICAgICAgcHJpdmF0ZSBzaGFyZWRTdGF0ZVNlcnZpY2U6IFRjU2hhcmVkU3RhdGVTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIGdlbmVyYWxDb25maWdTZXJ2aWNlOiBUY0dlbmVyYWxDb25maWdTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIHJvdXRlcjogUm91dGVyXG4gICAgKSB7IH1cblxuICAgIHJlc29sdmUoKTogT2JzZXJ2YWJsZTxSb3V0ZUFjY2Vzc0NvbnRyb2xDb25maWd1cmF0aW9uRWxlbWVudD4ge1xuIFxuICAgICAgICBjb25zdCBhY2Nlc3NDb250cm9sQ29uZmlndXJhdGlvbiQgPSBuZXcgQWNjZXNzQ29udHJvbENvbmZpZ3VyYXRpb25SZXNvbHZlcih0aGlzLmxvY2F0aW9uLCB0aGlzLmh0dHAsIHRoaXMuYWNjZXNzQ29udHJvbFNlcnZpY2UpLnJlc29sdmUoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIHdlIHdpbGwgbmVlZCB0aGUgYWN0aXZlIHVzZXIgcm9sZVxuICAgICAgICBjb25zdCBhY3RpdmVSb2xlUmVzID0gbmV3IFJvbGVBY3RpdmVSZXNvbHZlcih0aGlzLnJvbGVzU2VydmljZSwgdGhpcy5saXZlYXBwcywgdGhpcy5zaGFyZWRTdGF0ZVNlcnZpY2UsIHRoaXMuZ2VuZXJhbENvbmZpZ1NlcnZpY2UsIHRoaXMuaHR0cCwgdGhpcy5sb2NhdGlvbiwgdGhpcy5yb3V0ZXIpO1xuICAgICAgICBjb25zdCBhY3RpdmVSb2xlJCA9IGFjdGl2ZVJvbGVSZXMucmVzb2x2ZSgpO1xuXG4gICAgICAgIC8vIHJ1biBib3RoIGluIHBhcmFsbGVsIHRoZW4gY2hlY2sgYWNjZXNzXG4gICAgICAgIGNvbnN0IGFjY2Vzc0NvbnRyb2wkID0gZm9ya0pvaW4oYWNjZXNzQ29udHJvbENvbmZpZ3VyYXRpb24kLCBhY3RpdmVSb2xlJCkucGlwZShcbiAgICAgICAgICAgIG1hcCgoW2FjY2Vzc0NvbmZpZywgYWN0aXZlUm9sZV0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjZXNzQ29uZmlnLmNvbmZpZ3VyYXRpb24uZmluZChlbGVtZW50ID0+IGVsZW1lbnQucm9sZUlkID09PSBhY3RpdmVSb2xlLmlkKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIGFjY2Vzc0NvbnRyb2wkO1xuICAgIH1cblxufVxuIl19