/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @ngdoc component
 * @name mockingInterceptor
 *
 * @description
 * This interceptor attempts to use local json files from the assets directory to mock Tibco Cloud API calls
 *
 * Each mock file can contain either a single response or a "mockedResponses" object that contains specific URLs and responses
 *
 * @usage
 *
 *
 *
 */
import { Injectable } from '@angular/core';
import { HttpRequest, HttpResponse, HttpClient } from '@angular/common/http';
import { throwError } from 'rxjs';
import { map, catchError, delay } from 'rxjs/operators';
export class MockingInterceptor {
    /**
     * @param {?} http
     */
    constructor(http) {
        this.http = http;
        this.MOCK_BASE_PATH = '/assets/mocks';
        this.sendRequest = (/**
         * @param {?} req
         * @param {?} next
         * @return {?}
         */
        (req, next) => {
            return next.handle(req);
        });
    }
    /**
     * @param {?} url
     * @return {?}
     */
    readMockJSON(url) {
        return this.http.get(url);
    }
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    intercept(req, next) {
        // save original request
        /** @type {?} */
        const originalReq = req.clone();
        // dont mock anything from assets folder
        /** @type {?} */
        const urlparts = req.url.split('.');
        /** @type {?} */
        const pathparts = urlparts[0].split('/');
        if (pathparts[1] === 'assets') {
            return this.sendRequest(originalReq, next);
        }
        // try and find a mock response
        /** @type {?} */
        const resource = originalReq.url.split('?')[0];
        /** @type {?} */
        const segments = resource.split('/');
        /** @type {?} */
        const seg2 = resource.split('/');
        /** @type {?} */
        let path = this.MOCK_BASE_PATH;
        // ignore the http/url parts if present
        /** @type {?} */
        let responseType = 'json';
        if (segments[0] === 'http:' || segments[0] === 'https:') {
            segments.splice(0, 3);
            // we are getting a webresource (will only work for text based resources like svg)
            if (segments[0] === 'webresource') {
                responseType = 'text';
            }
        }
        else {
            // just remove the blank part
            segments.splice(0, 1);
        }
        segments.splice(0, segments.length).forEach((/**
         * @param {?} seg
         * @return {?}
         */
        (seg) => {
            path = path + '/' + seg;
        }));
        if (responseType !== 'text') {
            path = path + '.json';
        }
        else {
            path = path + '.txt';
        }
        /** @type {?} */
        let options = {};
        if (responseType === 'text') {
            options = { responseType: 'text' };
        }
        /** @type {?} */
        const httpRequest = new HttpRequest((/** @type {?} */ ('GET')), path, options);
        req = Object.assign(req, httpRequest);
        req = req.clone();
        return next.handle(req).pipe(delay(100), map((/**
         * @param {?} data
         * @return {?}
         */
        data => {
            /** @type {?} */
            let d = (/** @type {?} */ (data));
            if (d.status === 200) {
                // return the body of the cached response loaded from file
                console.log(originalReq.url);
                /** @type {?} */
                let mockedResponse;
                if (data['body']['mockedResponses']) {
                    // multi mocked response file
                    if (data['body']['mockedResponses'][originalReq.url]) {
                        data['body'] = data['body']['mockedResponses'][originalReq.url];
                        d = (/** @type {?} */ (data));
                        mockedResponse = new HttpResponse(d);
                    }
                    else {
                        // no mock for this URL
                        // todo: there is a bug here that this does not trigger the real call
                        throwError('no mock for this url - no response sent');
                    }
                }
                else {
                    // single mocked response file
                    mockedResponse = new HttpResponse(d);
                }
                return mockedResponse;
            }
            else {
                return data;
            }
        })), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => {
            // no mock file so make real request
            return this.sendRequest(originalReq, next);
        })));
    }
}
MockingInterceptor.decorators = [
    { type: Injectable }
];
/** @nocollapse */
MockingInterceptor.ctorParameters = () => [
    { type: HttpClient }
];
if (false) {
    /** @type {?} */
    MockingInterceptor.prototype.MOCK_BASE_PATH;
    /** @type {?} */
    MockingInterceptor.prototype.sendRequest;
    /**
     * @type {?}
     * @private
     */
    MockingInterceptor.prototype.http;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9ja2luZy1pbnRlcmNlcHRvci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0B0aWJjby10Y3N0ay90Yy1jb3JlLWxpYi8iLCJzb3VyY2VzIjpbImxpYi9pbnRlcmNlcHRvcnMvbW9ja2luZy1pbnRlcmNlcHRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFlQSxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ3pDLE9BQU8sRUFBWSxXQUFXLEVBQUUsWUFBWSxFQUFnQyxVQUFVLEVBQWMsTUFBTSxzQkFBc0IsQ0FBQztBQUNqSSxPQUFPLEVBQW9DLFVBQVUsRUFBQyxNQUFNLE1BQU0sQ0FBQztBQUNuRSxPQUFPLEVBQUMsR0FBRyxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUd0RCxNQUFNLE9BQU8sa0JBQWtCOzs7O0lBRzdCLFlBQW9CLElBQWdCO1FBQWhCLFNBQUksR0FBSixJQUFJLENBQVk7UUFGcEMsbUJBQWMsR0FBRyxlQUFlLENBQUM7UUFtR2pDLGdCQUFXOzs7OztRQUFHLENBQ1osR0FBcUIsRUFDckIsSUFBaUIsRUFBOEIsRUFBRTtZQUNqRCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDMUIsQ0FBQyxFQUFBO0lBcEdELENBQUM7Ozs7O0lBRU0sWUFBWSxDQUFDLEdBQUc7UUFDckIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM1QixDQUFDOzs7Ozs7SUFFRCxTQUFTLENBQUMsR0FBcUIsRUFBRSxJQUFpQjs7O2NBRzFDLFdBQVcsR0FBRyxHQUFHLENBQUMsS0FBSyxFQUFFOzs7Y0FHekIsUUFBUSxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQzs7Y0FDN0IsU0FBUyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FB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QkFBTTt3QkFDTCx1QkFBdUI7d0JBQ3ZCLHFFQUFxRTt3QkFDckUsVUFBVSxDQUFDLHlDQUF5QyxDQUFDLENBQUM7cUJBQ3ZEO2lCQUNGO3FCQUFNO29CQUNMLDhCQUE4QjtvQkFDOUIsY0FBYyxHQUFHLElBQUksWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUN0QztnQkFDRCxPQUFPLGNBQWMsQ0FBQzthQUN2QjtpQkFBTTtnQkFDTCxPQUFPLElBQUksQ0FBQzthQUNiO1FBQ0gsQ0FBQyxFQUNGLEVBQ0QsVUFBVTs7OztRQUNSLEtBQUssQ0FBQyxFQUFFO1lBQ04sb0NBQW9DO1lBQ3BDLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDN0MsQ0FBQyxFQUNGLENBQ0YsQ0FBQztJQUNKLENBQUM7OztZQW5HRixVQUFVOzs7O1lBSmlFLFVBQVU7Ozs7SUFNcEYsNENBQWlDOztJQW1HakMseUNBSUM7Ozs7O0lBckdXLGtDQUF3QiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG5nZG9jIGNvbXBvbmVudFxuICogQG5hbWUgbW9ja2luZ0ludGVyY2VwdG9yXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGlzIGludGVyY2VwdG9yIGF0dGVtcHRzIHRvIHVzZSBsb2NhbCBqc29uIGZpbGVzIGZyb20gdGhlIGFzc2V0cyBkaXJlY3RvcnkgdG8gbW9jayBUaWJjbyBDbG91ZCBBUEkgY2FsbHNcbiAqXG4gKiBFYWNoIG1vY2sgZmlsZSBjYW4gY29udGFpbiBlaXRoZXIgYSBzaW5nbGUgcmVzcG9uc2Ugb3IgYSBcIm1vY2tlZFJlc3BvbnNlc1wiIG9iamVjdCB0aGF0IGNvbnRhaW5zIHNwZWNpZmljIFVSTHMgYW5kIHJlc3BvbnNlc1xuICpcbiAqIEB1c2FnZVxuICpcbiAqXG4gKlxuICovXG5cbmltcG9ydCB7SW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0h0dHBFdmVudCwgSHR0cFJlcXVlc3QsIEh0dHBSZXNwb25zZSwgSHR0cEludGVyY2VwdG9yLCBIdHRwSGFuZGxlciwgSHR0cENsaWVudCwgSHR0cEhlYWRlcnN9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7T2JzZXJ2YWJsZSwgb2YsIG9uRXJyb3JSZXN1bWVOZXh0LCB0aHJvd0Vycm9yfSBmcm9tICdyeGpzJztcbmltcG9ydCB7bWFwLCBjYXRjaEVycm9yLCBkZWxheX0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTW9ja2luZ0ludGVyY2VwdG9yIGltcGxlbWVudHMgSHR0cEludGVyY2VwdG9yIHtcbiAgTU9DS19CQVNFX1BBVEggPSAnL2Fzc2V0cy9tb2Nrcyc7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBodHRwOiBIdHRwQ2xpZW50KSB7XG4gIH1cblxuICBwdWJsaWMgcmVhZE1vY2tKU09OKHVybCk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuaHR0cC5nZXQodXJsKTtcbiAgfVxuXG4gIGludGVyY2VwdChyZXE6IEh0dHBSZXF1ZXN0PGFueT4sIG5leHQ6IEh0dHBIYW5kbGVyKSB7XG5cbiAgICAvLyBzYXZlIG9yaWdpbmFsIHJlcXVlc3RcbiAgICBjb25zdCBvcmlnaW5hbFJlcSA9IHJlcS5jbG9uZSgpO1xuXG4gICAgLy8gZG9udCBtb2NrIGFueXRoaW5nIGZyb20gYXNzZXRzIGZvbGRlclxuICAgIGNvbnN0IHVybHBhcnRzID0gcmVxLnVybC5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHBhdGhwYXJ0cyA9IHVybHBhcnRzWzBdLnNwbGl0KCcvJyk7XG5cbiAgICBpZiAocGF0aHBhcnRzWzFdID09PSAnYXNzZXRzJykge1xuICAgICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qob3JpZ2luYWxSZXEsIG5leHQpO1xuICAgIH1cblxuXG4gICAgLy8gdHJ5IGFuZCBmaW5kIGEgbW9jayByZXNwb25zZVxuICAgIGNvbnN0IHJlc291cmNlID0gb3JpZ2luYWxSZXEudXJsLnNwbGl0KCc/JylbMF07XG4gICAgY29uc3Qgc2VnbWVudHM6IHN0cmluZ1tdID0gcmVzb3VyY2Uuc3BsaXQoJy8nKTtcbiAgICBjb25zdCBzZWcyOiBzdHJpbmdbXSA9IHJlc291cmNlLnNwbGl0KCcvJyk7XG4gICAgbGV0IHBhdGggPSB0aGlzLk1PQ0tfQkFTRV9QQVRIO1xuICAgIC8vIGlnbm9yZSB0aGUgaHR0cC91cmwgcGFydHMgaWYgcHJlc2VudFxuICAgIGxldCByZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgaWYgKHNlZ21lbnRzWzBdID09PSAnaHR0cDonIHx8IHNlZ21lbnRzWzBdID09PSAnaHR0cHM6Jykge1xuICAgICAgc2VnbWVudHMuc3BsaWNlKDAsIDMpO1xuICAgICAgLy8gd2UgYXJlIGdldHRpbmcgYSB3ZWJyZXNvdXJjZSAod2lsbCBvbmx5IHdvcmsgZm9yIHRleHQgYmFzZWQgcmVzb3VyY2VzIGxpa2Ugc3ZnKVxuICAgICAgaWYgKHNlZ21lbnRzWzBdID09PSAnd2VicmVzb3VyY2UnKSB7XG4gICAgICAgIHJlc3BvbnNlVHlwZSA9ICd0ZXh0JztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8ganVzdCByZW1vdmUgdGhlIGJsYW5rIHBhcnRcbiAgICAgIHNlZ21lbnRzLnNwbGljZSgwLCAxKTtcbiAgICB9XG4gICAgc2VnbWVudHMuc3BsaWNlKDAsIHNlZ21lbnRzLmxlbmd0aCkuZm9yRWFjaCgoc2VnKSA9PiB7XG4gICAgICBwYXRoID0gcGF0aCArICcvJyArIHNlZztcbiAgICB9KTtcbiAgICBpZiAocmVzcG9uc2VUeXBlICE9PSAndGV4dCcpIHtcbiAgICAgIHBhdGggPSBwYXRoICsgJy5qc29uJztcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IHBhdGggKyAnLnR4dCc7XG4gICAgfVxuXG4gICAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgICBpZiAocmVzcG9uc2VUeXBlID09PSAndGV4dCcpIHtcbiAgICAgIG9wdGlvbnMgPSB7IHJlc3BvbnNlVHlwZTogJ3RleHQnIH07XG4gICAgfVxuICAgIGNvbnN0IGh0dHBSZXF1ZXN0ID0gbmV3IEh0dHBSZXF1ZXN0KFxuICAgICAgPGFueT4nR0VUJyxcbiAgICAgIHBhdGgsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICByZXEgPSBPYmplY3QuYXNzaWduKHJlcSwgaHR0cFJlcXVlc3QpO1xuICAgIHJlcSA9IHJlcS5jbG9uZSgpO1xuICAgIHJldHVybiBuZXh0LmhhbmRsZShyZXEpLnBpcGUoXG4gICAgICBkZWxheSgxMDApLFxuICAgICAgbWFwKFxuICAgICAgICBkYXRhID0+IHtcbiAgICAgICAgICBsZXQgZCA9IDxIdHRwUmVzcG9uc2U8YW55Pj4gZGF0YTtcbiAgICAgICAgICBpZiAoZC5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBib2R5IG9mIHRoZSBjYWNoZWQgcmVzcG9uc2UgbG9hZGVkIGZyb20gZmlsZVxuICAgICAgICAgICAgY29uc29sZS5sb2cob3JpZ2luYWxSZXEudXJsKTtcbiAgICAgICAgICAgIGxldCBtb2NrZWRSZXNwb25zZTogSHR0cFJlc3BvbnNlPGFueT47XG4gICAgICAgICAgICBpZiAoZGF0YVsnYm9keSddWydtb2NrZWRSZXNwb25zZXMnXSkge1xuICAgICAgICAgICAgICAvLyBtdWx0aSBtb2NrZWQgcmVzcG9uc2UgZmlsZVxuICAgICAgICAgICAgICBpZiAoZGF0YVsnYm9keSddWydtb2NrZWRSZXNwb25zZXMnXVtvcmlnaW5hbFJlcS51cmxdKSB7XG4gICAgICAgICAgICAgICAgZGF0YVsnYm9keSddID0gZGF0YVsnYm9keSddWydtb2NrZWRSZXNwb25zZXMnXVtvcmlnaW5hbFJlcS51cmxdO1xuICAgICAgICAgICAgICAgIGQgPSA8SHR0cFJlc3BvbnNlPGFueT4+IGRhdGE7XG4gICAgICAgICAgICAgICAgbW9ja2VkUmVzcG9uc2UgPSBuZXcgSHR0cFJlc3BvbnNlKGQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5vIG1vY2sgZm9yIHRoaXMgVVJMXG4gICAgICAgICAgICAgICAgLy8gdG9kbzogdGhlcmUgaXMgYSBidWcgaGVyZSB0aGF0IHRoaXMgZG9lcyBub3QgdHJpZ2dlciB0aGUgcmVhbCBjYWxsXG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcignbm8gbW9jayBmb3IgdGhpcyB1cmwgLSBubyByZXNwb25zZSBzZW50Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHNpbmdsZSBtb2NrZWQgcmVzcG9uc2UgZmlsZVxuICAgICAgICAgICAgICBtb2NrZWRSZXNwb25zZSA9IG5ldyBIdHRwUmVzcG9uc2UoZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbW9ja2VkUmVzcG9uc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIGNhdGNoRXJyb3IoXG4gICAgICAgIGVycm9yID0+IHtcbiAgICAgICAgICAvLyBubyBtb2NrIGZpbGUgc28gbWFrZSByZWFsIHJlcXVlc3RcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdChvcmlnaW5hbFJlcSwgbmV4dCk7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgc2VuZFJlcXVlc3QgPSAoXG4gICAgcmVxOiBIdHRwUmVxdWVzdDxhbnk+LFxuICAgIG5leHQ6IEh0dHBIYW5kbGVyKTogT2JzZXJ2YWJsZTxIdHRwRXZlbnQ8YW55Pj4gPT4ge1xuICAgIHJldHVybiBuZXh0LmhhbmRsZShyZXEpO1xuICB9XG59XG4iXX0=